/*
FORMATO DELLA FUNZIONE
void GestionePrestitiMenu(Utente* database_utenti,Libro* database_libri, Prestito* database_prestiti,int* utenti_inseriti, int* libri_inseriti,int* prestiti_inseriti,int* capacita_attuale_prestiti);
*/


// SOLO PER TEST//

# include <stdio.h>
# include <string.h>
# include <stdlib.h>
# include <ctype.h>

typedef struct {
    char codice_ISBN[18];
    char titolo[101];
    char autore[51];
    int anno_pubblicazione;
    int numero_copie;
    char genere[31];
} Libro;

typedef struct {
    int codice_utente;
    char nome[51];
    char cognome[51];
    char email[81];
    char data_iscrizione[11];
} Utente;

typedef struct {
    int codice_prestito;
    char codice_ISBN_libro[18];
    int codice_utente;
    char data_prestito[11];
    char data_restituzione_prevista[11];
    int restituito;
} Prestito;

// SOLO PER TEST //

// PROTOTIPI DELLA FUNZIONE //

// Registrazione prestiti
Prestito* registra_prestito(Libro* database_libri,Utente* database_utenti,Prestito* database_prestiti,int* prestiti_inseriti,int* capacita_attuale_prestiti,int libri_inseriti,int utenti_inseriti);
void richiedi_libro_utente(Libro* database_libri,Utente* database_utenti,int* utenti_inseriti,int libri_inseriti,int*posizione_utente,int* posizione_libro);    
    // Richiesta libro
    int richiesta_codice_ISBN(Libro* database_libri,int libri_inseriti,char ISBN[],int* posizione_libro);
    int invalida_ISBN(char ISBN[18]);
    int invalida_data(char data[11]);
    void controlla_esistenza_libro(Libro* database_libri,int libri_inseriti,char ISBN[],int* posizione_libro);
    int menu_codice_ISBN_non_valido();
    // Richiesta utente
    void richiesta_codice_utente(Utente* database_utenti, int utenti_inseriti, int* codice, int* posizione_utente);
    void controlla_esistenza_utente(Utente* database_utenti,int utenti_inseriti,int codice,int* posizione_utente);
    int menu_codice_utente_non_valido();
    // Calcolo data di restituzione
    void calcola_30_giorni_dopo(char data[]);
    void estrapola_data_numerica(char data[],int* anno, int* mese, int* giorno);
    int calcola_data_valore(int* anno,int* mese, int* giorno);
    void costruisci_data_da_valore_data(int data_valore,int* anno, int* mese, int* giorno);
    void costruisci_stringa_da_data(char data[],int anno,int mese,int giorno);

// Registrazione restituzioni
void registra_restituzione(Prestito* database_prestiti, Libro* database_libri,int prestiti_inseriti,int libri_inseriti);
int menu_codice_prestito_errato();

// Visualizzazione dei prestiti attivi
void visualizza_prestiti_attivi(Utente* database_utenti,Prestito* database_prestiti,Libro* database_libri,int libri_inseriti,int prestiti_inseriti,int utenti_inseriti);

// Visualizzazione storico dei prestiti
void visualizza_storico_prestiti_utente(Utente* database_utenti,Prestito* database_prestiti,int utenti_inseriti,int prestiti_inseriti);
void stampa_prestito(Prestito* database_prestiti,int indice_prestito_assoluto,int indice_prestito_nel_ciclo_specifico);

int main() {
    
    // SOLO Per TEST //

    Utente* database_utenti;
    Libro* database_libri;
    Prestito* database_prestiti;
    int val_utenti_inseriti;
    int* utenti_inseriti=&val_utenti_inseriti;
    int val_libri_inseriti;
    int* libri_inseriti=&val_libri_inseriti;
    int val_prestiti_inseriti;
    int* prestiti_inseriti = &val_prestiti_inseriti;
    int val_capacita_attuale_prestiti;
    int* capacita_attuale_prestiti=&val_capacita_attuale_prestiti;

    // SOLO PER TEST //

    int scelta;

    do {        
        // Stampa Menù
        printf("\n== MENU' GESTIONE PRESTITI ==\n");
        printf("  1. Registra un nuovo prestito;\n");
        printf("  2. Registra la restituzione di un libro;\n");
        printf("  3. Visualizza tutti i prestiti attivi;\n");
        printf("  4. Visualizza lo storico dei prestiti di un utente;\n");
        printf("  5. Torna al menù principale.\n");
        printf("\nLa tua scelta: ");
        scanf("%d",&scelta);
        
        if (*prestiti_inseriti!=0 || scelta == 1) {
            switch (scelta)
            {
            case 1:
                Prestito* temp;
                temp = registra_prestito(database_libri,database_utenti,database_prestiti,prestiti_inseriti,capacita_attuale_prestiti,*libri_inseriti,*utenti_inseriti);
                if (temp == NULL) { // Controllo che l'eventuale riallocazione sia avvenuta con successo
                    printf("\nErrore di allocazione in memoria! Verrai reindirizzato al menù gestione utenti\n");
                } else {
                    database_prestiti = temp; // Se è avvenuta con successo, aggiorno tale puntatore.
                    free(temp);
                }
                break;
            
            case 2:
                registra_restituzione(database_prestiti,database_libri,*prestiti_inseriti,*libri_inseriti);
                break;
            
            case 3:
                visualizza_prestiti_attivi(database_utenti,database_prestiti,database_libri,*libri_inseriti,*prestiti_inseriti,*utenti_inseriti);
                break;
            
            case 4:
                visualizza_storico_prestiti_utente(database_utenti,database_prestiti,*utenti_inseriti,*prestiti_inseriti);
                break;
            
            case 5:
                break;
            
            default:
                printf("La scelta deve essere un numero tra 1 e 5 (compresi)! Riprova:\n");
                break;
            }
        } else {
            printf("Non sono presenti prestiti. Per questo motivo le uniche scelte ammesse sono 1 e 5. Riprova:\n");
        }
    } while (scelta != 5);
    return 0;
}

Prestito* registra_prestito(Libro* database_libri,Utente* database_utenti,Prestito* database_prestiti,int* prestiti_inseriti,int* capacita_attuale_prestiti,int libri_inseriti,int utenti_inseriti) {

    // Richiesta libro e utente + controllo
    int flag_inserimento;
    int posizione_libro;
    int posizione_utente;
    richiedi_libro_utente(database_libri,database_utenti,&utenti_inseriti,libri_inseriti,&posizione_utente,&posizione_libro);
    if (posizione_utente == -1 || posizione_libro == -1) {     // Se una delle due posizioni risulta ancora -1, allora c'è stato un errore nella richiesta del libro oppure  
                                                                // una richiesta di uscita dall'inserimento prestiti (tutti sono opportunamente segnalati nelle varie funzioni)
        return database_prestiti;
    }

    // Riallocazione dinamica database_prestiti
    if (*capacita_attuale_prestiti==*prestiti_inseriti) {
        database_prestiti = realloc(database_prestiti,2* *capacita_attuale_prestiti*sizeof(Prestito));
        if (database_prestiti == NULL) {
            return NULL;
        }
        *capacita_attuale_prestiti = *capacita_attuale_prestiti*2;
    }
    
    // Inserimento codice ISBN e codice utente
    strcpy(database_prestiti[*prestiti_inseriti].codice_ISBN_libro,database_libri[posizione_libro].codice_ISBN);
    database_prestiti[*prestiti_inseriti].codice_utente = database_utenti[posizione_utente].codice_utente;

    // Diminuzione numero di copie
    database_libri[posizione_libro].numero_copie--;

    // Inserimento data_prestito
    char data[11];
    do {
        printf("\nInserisici la data del prestito: ");
        scanf("%10s",data);
        if (invalida_data(data)) {
            printf("Formato non valido! Formato corretto: gg/mm/aaaa. Riprova: \n");
        }
    } while(invalida_data(data));
    strcpy(database_prestiti[*prestiti_inseriti].data_prestito,data);

    // Calcolo data_restituzione_prevista
    calcola_30_giorni_dopo(data);
    strcpy(database_prestiti[*prestiti_inseriti].data_restituzione_prevista,data);

    // Restituito = 0
    database_prestiti[*prestiti_inseriti].restituito=0;

    // Generazione codice prestito
    database_prestiti[*prestiti_inseriti].codice_prestito=(*prestiti_inseriti)+1;
    (*prestiti_inseriti)++;

    return database_prestiti;
}

void richiedi_libro_utente(Libro* database_libri,Utente* database_utenti,int* utenti_inseriti,int libri_inseriti,int*posizione_utente,int* posizione_libro) {

    char ISBN[18];
    int codice=0;
    int exit_flag_ISBN;
    int exit_flag_codice_utente;
    
    // Richiesta codice ISBN
    exit_flag_ISBN=richiesta_codice_ISBN(database_libri,libri_inseriti,ISBN,posizione_libro);
    if (exit_flag_ISBN==-1) { // Se c'è errore nella richiesta del codice ISBN, posso (anzi devo) evitare di controllare il codice utente
        return;
    }

    // Richiesta codice utente
    richiesta_codice_utente(database_utenti,*utenti_inseriti,&codice,posizione_utente);
    return;
}

int invalida_ISBN(char ISBN[18]) {
    if (strlen(ISBN)!=17) {
        return 1;
    }
    return  ISBN[0] < '0' || ISBN[0] > '9' ||
            ISBN[1] < '0' || ISBN[1] > '9' ||
            ISBN[2] < '0' || ISBN[2] > '9' ||
            ISBN[4] < '0' || ISBN[4] > '9' ||
            ISBN[6] < '0' || ISBN[6] > '9' ||
            ISBN[7] < '0' || ISBN[7] > '9' ||
            ISBN[8] < '0' || ISBN[8] > '9' ||
            ISBN[9] < '0' || ISBN[9] > '9' ||
            ISBN[11] < '0' || ISBN[11] > '9' ||
            ISBN[12] < '0' || ISBN[12] > '9' ||
            ISBN[13] < '0' || ISBN[13] > '9' ||
            ISBN[14] < '0' || ISBN[14] > '9' ||
            ISBN[16] < '0' || ISBN[16] > '9' ||
            ISBN[3] != '-' || ISBN[5] != '-' ||
            ISBN[10] != '-' || ISBN[15] != '-';
}

int invalida_data(char data[11]) {
    if (strlen(data)!=10) {
        return 1;
    }
    return  data[0] < '0' || data[0] > '9' ||
            data[1] < '0' || data[1] > '9' ||
            data[3] < '0' || data[3] > '9' ||
            data[4] < '0' || data[4] > '9' ||
            data[6] < '0' || data[6] > '9' ||
            data[7] < '0' || data[7] > '9' ||
            data[8] < '0' || data[8] > '9' ||
            data[9] < '0' || data[9] > '9' ||
            data[2] != '/' || data[5] != '/';
}

int menu_codice_ISBN_non_valido() {
    int scelta=0;
    printf("\nCosa vuoi fare ora?\n");
    printf("\n  1. Inserire un nuovo codice ISBN per il libro\n");
    printf("  2. Tornare al menù di gestione dei prestiti.\n");
    do {
        scanf("%d",&scelta);
        switch (scelta)
        {
        case 1:
            return 0;
        
        case 2:
            return -1;

        default:
            printf("\nLa scelta deve essere 1 oppure 2! Riprova: ");
            break;
        }
    } while(scelta != 1 && scelta != 2);
}

void controlla_esistenza_libro(Libro* database_libri,int libri_inseriti,char ISBN[],int* posizione_libro) {
    for (int i=0;i<libri_inseriti;i++) {
        if (strcmp(ISBN,database_libri[i].codice_ISBN)==0) {
            printf("Libro trovato correttamente!\n");
            *posizione_libro=i;
            return;
        } 
    }
    printf("Non è stato trovato alcun libro con tale codice!");
    *posizione_libro=-1;
    return;
}

int richiesta_codice_ISBN(Libro* database_libri,int libri_inseriti,char ISBN[],int* posizione_libro) {
    do {
        printf("\nInserisci il codice ISBN del libro: ");
        scanf("%17s",ISBN);

        // Controllo inserimento ISBN
        if (invalida_ISBN(ISBN)) {
            printf("\nIl codice ISBN è stato inserito con formato errato! Formato corretto: XXX-X-XXXX-XXXX-X.\n");
        } else {
            // Calcolo posizione libro
            controlla_esistenza_libro(database_libri,libri_inseriti,ISBN,posizione_libro);
            if (*posizione_libro!=-1 && database_libri[*posizione_libro].numero_copie==0) { // Controllo che ci siano copie del libro
                printf("Copie del libro non disponibili!");
                *posizione_libro=-1; // Piuttosto che inventare una nuova variabile, faccio valere posizione_libro = -1 (come se il libro non fosse nel catalogo).
                                    // Ciò non dà problemi perché gli unici messaggi relativi a posizione_libro provengono da "controlla_esistenza_libro"
            }   
        }
        
        // Controllo se l'utente vuole ancora inserire un prestito
        if (invalida_ISBN(ISBN) || *posizione_libro == -1) {
            int exit_flag;
            exit_flag=menu_codice_ISBN_non_valido();
            if (exit_flag == -1) {
                return -1;
            }
        }

    } while (invalida_ISBN(ISBN) || *posizione_libro == -1);
    return 0;
}

void richiesta_codice_utente(Utente* database_utenti, int utenti_inseriti, int* codice, int* posizione_utente) {
    do {
        printf("\nInserisci il codice utente: ");
        scanf("%d",codice);

        // Controllo inserimento codice utente
        if (*codice<=0) {
            printf("\nIl codice utente deve essere positivo!\n");
        } else {
            // Calcolo posizione utente
            controlla_esistenza_utente(database_utenti,utenti_inseriti,*codice,posizione_utente);
        }

        // Controllo se l'utente vuole ancora inserire un prestito
        if (*codice<=0 || *posizione_utente == -1) {
            int exit_flag;
            exit_flag = menu_codice_utente_non_valido();
            if (exit_flag == -1) {
                return;
            }
        }

    } while (*posizione_utente == -1 || *codice <= 0);
}

void controlla_esistenza_utente(Utente* database_utenti,int utenti_inseriti,int codice,int* posizione_utente) {
    for (int i=0;i<utenti_inseriti;i++) {
        if (codice == database_utenti[i].codice_utente) {
            printf("\nUtente trovato correttamente!\n");
            *posizione_utente=i;
            return;
        } 
    }
    printf("Non è stato trovato alcun utente con tale codice!");
    *posizione_utente=-1;
}

int menu_codice_utente_non_valido() {
    int scelta=0;
    printf("\nCosa vuoi fare ora?\n");
    printf("\n  1. Inserire un nuovo codice utente\n");
    printf("  2. Tornare al menù di gestione dei prestiti.\n");
    printf("\nLa tua scelta: ");
    do {
        scanf("%d",&scelta);
        switch (scelta)
        {
        case 1:
            return 0;
        
        case 2:
            return -1;

        default:
            printf("\nLa scelta deve essere 1 oppure 2! Riprova: ");
            break;
        }
    } while(scelta != 1 && scelta != 2);
}

void calcola_30_giorni_dopo(char data[]) {
    int anno;
    int mese;
    int giorno;
    int data_valore;
    estrapola_data_numerica(data,&anno,&mese,&giorno);
    data_valore=calcola_data_valore(&anno,&mese,&giorno);
    data_valore+=30;
    costruisci_data_da_valore_data(data_valore,&anno,&mese,&giorno);
    costruisci_stringa_da_data(data,anno,mese,giorno);
}

void estrapola_data_numerica(char data[],int* anno, int* mese, int* giorno) {
    *anno = (data[9]-'0') + 10*(data[8]-'0') + 100*(data[7]-'0') + 1000*(data[6]-'0');
    *mese = (data[4]-'0') + 10*(data[3]-'0');
    *giorno = (data[1]-'0') + 10*(data[0]-'0');
}

int calcola_data_valore(int* anno,int* mese, int* giorno) {
    int data_valore;
    int trentuno=0;
    int ventotto=0;
    for (int i=1; i<*mese; i++) {
        if(i==1 || i==3 || i==5 || i==7 || i==8 || i==10 || i==12) {
        trentuno++;
        } else if (i==2) {
            ventotto++;
        }
    }    
    data_valore =   *anno*365                                                                                       // giorni per ogni anno passato
                    +(*anno-1)/4-(*anno-1)/100+(*anno-1)/400                                                        // anni bisestili passati
                    +(*mese-1)*30 + trentuno - (2-(((*anno%4)==0 && (*anno%100)!=0) || (*anno%400)==0))*ventotto    // giorni per mese passato
                    +*giorno;                                                                                       // giorni passati in questo mese
    return data_valore;
}

void costruisci_data_da_valore_data(int data_valore,int* anno, int* mese, int* giorno) {
    
    int valore_anno;
    int flag_non_bisestile;

    int anno_provvisorio = data_valore / 365;

    // Aggiustamento anno
    do {
        anno_provvisorio++;
        valore_anno = anno_provvisorio*365+(anno_provvisorio-1)/4-(anno_provvisorio-1)/100+(anno_provvisorio-1)/400;
        flag_non_bisestile = ((anno_provvisorio%4)!=0 || (anno_provvisorio%100)==0) && ((anno_provvisorio%400)!=0);
    } while (data_valore - valore_anno >= 365 + 1-  flag_non_bisestile);
    *anno=anno_provvisorio;
    
    // Calcolo mese e giorno
    int giorni_da_inizio_anno = data_valore - valore_anno;
    int giorni_dei_mesi[12] = {0,31,60-flag_non_bisestile,91-flag_non_bisestile,121-flag_non_bisestile,152-flag_non_bisestile,182-flag_non_bisestile,213-flag_non_bisestile,244-flag_non_bisestile,274-flag_non_bisestile,305-flag_non_bisestile,335-flag_non_bisestile};
    for (int i=1;i<12;i++) {
        if (giorni_da_inizio_anno<=giorni_dei_mesi[i]) {
            *mese = i;
            *giorno = giorni_da_inizio_anno - giorni_dei_mesi[i-1];
            return;
        }
    }
    *mese = 12;
    *giorno = giorni_da_inizio_anno-giorni_dei_mesi[11];
}

void costruisci_stringa_da_data(char data[],int anno,int mese,int giorno) {
    data[0] = giorno / 10 +'0';
    data[1] = giorno % 10 + '0';
    data[2] = '/';
    data[3] = (mese / 10) + '0';
    data[4] = mese % 10 + '0';
    data[5] = '/';
    data[6] = (anno / 1000) % 10 + '0';
    data[7] = (anno / 100) % 10 + '0';
    data[8] = (anno / 10) % 10 + '0';
    data[9] = (anno % 10) + '0';
    data[10] = '\0';
}

void registra_restituzione(Prestito* database_prestiti,Libro* database_libri, int prestiti_inseriti, int libri_inseriti) {
    
    // Richiedi prestito
    int codice;
    printf("\nInserisci il codice del prestito da modificare:\n");
    do{ 
        printf("\nLa tua scelta: ");
        scanf("%d",&codice);
        if (codice<=0) {
            printf("\nIl codice del prestito deve essere un numero positivo!\n");
        } else if (codice>prestiti_inseriti) { // Questo controllo funziona perché il codice è sequenziale.
            printf("\nIl codice del prestito è inesistente!\n");
        }

        if (codice<=0 || codice>prestiti_inseriti) {
            int flag=menu_codice_prestito_errato();
            if (flag==1) {
                return;
            }
        }
    } while (codice<=0 || codice>prestiti_inseriti);

    // Controllo esistenza codice, assegnazjone restituito e aumento numero di copie.
    for (int i=0;i<prestiti_inseriti;i++) {
        if (codice == database_prestiti[i].codice_prestito) {   
            database_prestiti[i].restituito=1;
            for (int j=0;j<libri_inseriti;j++) {
                if (strcmp(database_libri[j].codice_ISBN,database_prestiti[i].codice_ISBN_libro)==0) {
                    database_libri[j].numero_copie++;
                    break;
                }
            }
            break;
        }
    }
    printf("Prestito assegnato correttamente!");
    return;
}

int menu_codice_prestito_errato() {
    
    int scelta;
    printf("\nCosa vuoi fare?\n");
    printf("\n  1. Inserire un nuovo codice di prestito;\n");
    printf("  2. Tornare al menù gestione prestiti.");
    do {
        printf("\nLa tua scelta\n");
        scanf("%d",&scelta);
        switch (scelta) {
            
        case 1: 
            return 0;

        case 2:
            return 1;

        default:
            printf("\nLa scdlta deve esserd 1 oppure 2! Riprova:\n");
            break;
        }
    } while (scelta!=1 && scelta!=2);
    return 0;

}

void visualizza_prestiti_attivi(Utente* database_utenti,Prestito* database_prestiti,Libro* database_libri,int libri_inseriti,int prestiti_inseriti,int utenti_inseriti) {
    printf("\nEcco tutti i prestiti attivi al momento:\n");
    for (int i=0;i<prestiti_inseriti;i++) { // Ciclo sui prestiti inseriti
        if (database_prestiti[i].restituito==0) {
            printf("\nPrestito %d:\n",i+1);
            printf("\n  1. Codice prestito: %d\n",database_prestiti[i].codice_prestito);
            
            // Ricerca titolo e stampa
            char titolo[101];
            for (int j=0;j<libri_inseriti;j++) {
                if (strcmp(database_prestiti[i].codice_ISBN_libro,database_libri[j].codice_ISBN)==0) {
                    strcpy(titolo,database_libri[j].titolo);
                    break;
                }
            }
            printf("  2. Titolo del libro: %s\n",titolo);

            // Ricerca nome utente e stampa
            char nome[51];
            char cognome[51];
            for (int j=0;j<utenti_inseriti;j++) {
                if (database_prestiti[i].codice_utente == database_utenti[j].codice_utente) {
                    strcpy(nome,database_utenti[j].nome);
                    strcpy(cognome,database_utenti[j].cognome);
                    break;
                }
            }
            printf("  3. Nome utente: %s\n",nome);
            printf("  4. Cognome utente: %s\n",cognome);

            // Stampa data prestito e data restituzione
            printf("  5. Data prestito: %s",database_prestiti[i].data_prestito);
            printf("  6. Data di restituzione prevista: %s",database_prestiti[i].data_restituzione_prevista);
        }
    }
}

void visualizza_storico_prestiti_utente(Utente* database_utenti,Prestito* database_prestiti,int utenti_inseriti,int prestiti_inseriti) {
    
    int codice;
    int flag=-1;
    printf("\nInserisci il codice dell'utente che stai cercando: ");
    
    // Ciclo while per controllo codice utente inserito
    do {
        scanf("%d",&codice);
        if (codice<=0) {
            printf("\nIl codice deve essere positivo! Riprova: ");
        } else {
            for (int i=0;i<utenti_inseriti;i++) {
                if (database_utenti[i].codice_utente == codice) {
                    flag = 0;
                    printf("\nUtente trovato correttamente!\n");
                }
            }
        } 
    } while (flag == -1);
    
    // Stampo i prestiti non restituiti, salvo le posizioni di quelli restituiti  
    int indice_prestito_non_restituito=-1;
    int indice_prestito_restituito=-1;
    int* posizioni_restituiti=malloc(5*sizeof(int));
    int capacita_posizioni_restituiti = 5;

    // Controllo allocazione dinamica
    if (posizioni_restituiti==NULL) {
        printf("\nErrore di allocazione in memoria! Verrai reindirizzato al menù gestione prestiti.\n");
        return;
    }

    // Ciclo per scrittura prestiti non restituiti
    for (int i=0;i<prestiti_inseriti;i++) {
        if (database_prestiti[i].codice_utente == codice) {
            printf("\nPrestiti non restituiti:\n");
            if (database_prestiti[i].restituito == 0) {
                stampa_prestito(database_prestiti,i,indice_prestito_non_restituito++);
            }
        } else {
            if (capacita_posizioni_restituiti<=++indice_prestito_non_restituito) { // Eventuale riallocazione dinamica di posizioni_restituiti
                posizioni_restituiti = realloc(posizioni_restituiti,2*capacita_posizioni_restituiti*sizeof(int));
                if (posizioni_restituiti==NULL) {
                    printf("\nErrore di allocazione in memoria! Verrai reindirizzato al menù gestione prestiti.\n");
                    return;
                }
                capacita_posizioni_restituiti = 2*capacita_posizioni_restituiti;
            }
            posizioni_restituiti[indice_prestito_restituito]=i;
        }
    }

    // Stampa dei restituiti
    printf("\nPrestiti restituiti:\n");
    for (int i=0;i<=indice_prestito_restituito;i++) {
        stampa_prestito(database_prestiti,posizioni_restituiti[i],i);
    }

    free(posizioni_restituiti);
}

void stampa_prestito(Prestito* database_prestiti,int indice_prestito_assoluto,int indice_prestito_nel_ciclo_specifico) {
    printf("\nPrestito: %d\n",indice_prestito_nel_ciclo_specifico+1);
    printf("  1. Codice prestito: %d\n",database_prestiti[indice_prestito_assoluto].codice_prestito);
    printf("  2. Codice ISBN del libro: %s\n",database_prestiti[indice_prestito_assoluto].codice_ISBN_libro);
    printf("  3. Codice utente: %d\n",database_prestiti[indice_prestito_assoluto].codice_utente);
    printf("  4. Data prestito: %s\n",database_prestiti[indice_prestito_assoluto].data_prestito);
    printf("  5. Data di restituzione prevista: %s\n",database_prestiti[indice_prestito_assoluto].data_restituzione_prevista);
} 
